'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.outputConfig = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _ramda = require('ramda');

var _fs = require('fs');

var _stringifyObject = require('stringify-object');

var _stringifyObject2 = _interopRequireDefault(_stringifyObject);

var _loaderConfig = require('./loaderConfig');

var _loaderConfig2 = _interopRequireDefault(_loaderConfig);

var _installModules = require('./installModules');

var _installModules2 = _interopRequireDefault(_installModules);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

RegExp.prototype.toJSON = RegExp.prototype.toString;

// makeEntry :: Object -> Object
// extend answers object with entry
var makeEntry = function makeEntry(x) {
  return _extends({}, x, {
    initialEntry: x.entry, // Using this for loaderConfig
    entry: x.entry
  });
};

// createInitialOutputObj :: Object -> Object
// extend answers object with output object
var createInitialOutputObj = function createInitialOutputObj(x) {
  return _extends({}, x, {
    output: {
      path: x.outputPath,
      filename: x.outputFilename
    }
  });
};

// createPublicProp :: Object -> Boolean | Object
// if publicPathRequired output object with publicPath prop
var createPublicProp = function createPublicProp(x) {
  return x.publicPathRequired && _extends({}, x, {
    output: _extends({}, x.output, {
      publicPath: x.outputPublicPath
    })
  });
};

// loadersMap :: Object -> String -> Object
var loadersMap = function loadersMap(config) {
  return function (x) {
    return config[x.trim()];
  };
};

// createLoadersConfig :: Object -> Object
// extend answers object with mapped loader configs
var createLoadersConfig = function createLoadersConfig(x) {
  return _extends({}, x, {
    module: {
      loaders: (0, _ramda.map)(loadersMap((0, _loaderConfig2.default)(x.initialEntry)), x.loaders)
    }
  });
};

// grab only these properties out of our answers object
var finalProps = (0, _ramda.pick)(['entry', 'output', 'module']);

// outputConfig :: Answers -> Object
var outputConfig = exports.outputConfig = (0, _ramda.compose)(finalProps, createLoadersConfig, (0, _ramda.either)(createPublicProp, _ramda.identity), createInitialOutputObj, makeEntry);

// writeFinalAnswersAndTxtFile :: Object -> Object
// return final object so we can compose if needed
var writeFinalAnswersAndTxtFile = function writeFinalAnswersAndTxtFile(answers) {
  return function (final) {
    (0, _fs.writeFileSync)(answers.configFileName, final);
    return final;
  };
};

// fileTemplate :: String -> String
var fileTemplate = function fileTemplate(code) {
  return 'module.exports = ' + code;
};

// mapLoaders :: Object -> [String]
var mapLoaders = function mapLoaders(xs) {
  return (0, _ramda.map)(function (_ref) {
    var modules = _ref.modules;
    return modules;
  }, xs.loaders);
};

// removeModulesFromLoaders :: Object -> Object
// remove modules prop so we don't include in final output
var removeModulesFromLoaders = function removeModulesFromLoaders(x) {
  return _extends({}, x, {
    module: {
      loaders: (0, _ramda.map)((0, _ramda.pick)(['test', 'loaders', 'include', 'query']), x.module.loaders)
    }
  });
};

exports.default = function (answers) {
  var final = outputConfig(answers);

  // install modules
  (0, _ramda.compose)((0, _installModules2.default)(answers.configFileName), (0, _ramda.map)(_ramda.flatten), (0, _ramda.map)(mapLoaders), (0, _ramda.pick)(['module']))(final);

  var output = fileTemplate((0, _stringifyObject2.default)(removeModulesFromLoaders(final), {
    indent: '  '
  }));
  writeFinalAnswersAndTxtFile(answers)(output);
};